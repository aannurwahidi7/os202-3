---
permalink: /W04/
---
[HOME](../)

<br>
# Top 10 List of Week 04

1. [How the CPU can be shared by a set of processes](https://youtu.be/EWkQl0n0w5M)<br>
This video explained about introduction to CPU Scheduling. Why we need to know about CPU Scheduling? 
Because CPU Scheduling is the basis ofmultiprogrammed OS. By switching the CPU among processes, 
the operating system can make the computer more productive. As a result of CPU scheduling, 
we can improve both the utilization of the CPU and speed of the computer's response to its users. 
Please check that interesting explanation in the video!

2. [Memory Management in Linux](https://youtu.be/7aONIVSXiJ8)<br>
This video is an introduction to memory management in Linux included physical memory,
virtual memory, memory management unit (MMU), lookaside buffer. It also shows the advantages of 
each memory management. Virtual addresses, logical address and physical address explanation also included here

3. [The Memory Management Unit](https://youtu.be/7aONIVSXiJ8)<br>
Still from the same resources as number 2. The MMU is a hardware component which manages virtual
address mappings. The MMU operated on basic units of memory called pages. A page is a unit of memory
sized aligned at the page size. If you want to read a full version of continguous memory allocation please
read OSC 10th edition part 9.2.

4. [Shared Memory System](https://youtu.be/uHtzOFwgD74)
Shared memory is easily implemented with an MMU. Interprocess communication shared memory required communicating
processes to establish a region os shared memory. Typically, a shared-memory region resides in the address
space of the process creating the shared-memory segment. Normally, the OS tries to prevent one process
from accessing another process'memory and the shared memory required two or more processes agree to remove
restriction.

5. [First-Fit, Best-Fit, and Worst-Fit Strategies for Memory Allocation](https://courses.cs.vt.edu/csonline/OS/Lessons/MemoryAllocation/index.html)<br>
* First-fit explained there may be many holes in the memory, so that operating system, to reduce 
the amount of time it spends analyzing the available spaces, begins at the start of primary memory 
and allocates memory from the first hole it encounters large enough to satisfy the request. 
* Best-Fit, the allocator places a process in the smallest block of unallocated memory in which it will fit.
For example, suppose a process requests 12KB of memory and the memory manager currently has a list of unallocated 
blocks of 6KB, 14KB, 19KB, 11KB, and 13KB blocks. The best-fit strategy will allocate 12KB of the 13KB block to the process.
* Worst fit: The memory manager places a process in the largest block of unallocated memory available. The idea is 
that this placement will create the largest hold after the allocations, thus increasing the possibility that, 
compared to best fit, another process can use the remaining space. Using the same example as above, 
worst fit will allocate 12KB of the 19KB block to the process, leaving a 7KB block for future use.

6. [Logical Address VS Physical Address](https://www.geeksforgeeks.org/logical-and-physical-address-in-operating-system/)<br>
The basic difference between Logical and physical address is that Logical address is generated by CPU in 
perspective of a program whereas the physical address is a location that exists in the memory unit.
Logical address and physical address still have the other difference, please check the webiste!

7. [Paging System](https://en.wikipedia.org/wiki/6)<br>

8. [Translation from Logical to Physical Addresses in Paging System](https://en.wikipedia.org/wiki/7)<br>

9. [Hierarchial Paging, Hashed Paging, and Inverted Page Tables](https://en.wikipedia.org/wiki/8)<br>

10. [Swapping](https://en.wikipedia.org/wiki/10)<br>
